<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>renderer with Gamepad Support</title>

<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #0f0f0f;
    overflow: hidden;
    touch-action: none;
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
</style>
</head>

<body>
<canvas id="c"></canvas>

<script>
/* ================= CANVAS ================= */

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width  = Math.floor(canvas.clientWidth  * dpr);
  canvas.height = Math.floor(canvas.clientHeight * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resize);
resize();

/* ================= MOBILE DETECT ================= */

const IS_MOBILE =
  'ontouchstart' in window ||
  navigator.maxTouchPoints > 0;

/* ================= SCENE (CUBE) ================= */

/* 8 cube vertices (world space) */
const pointsWorld = [
  { x:-2, y:17, z:-2 }, // 0
  { x:-2, y:17, z: 2 }, // 1
  { x: 2, y:17, z:-2 }, // 2
  { x: 2, y:17, z: 2 }, // 3
  { x:-2, y:15, z:-2 }, // 4
  { x:-2, y:15, z: 2 }, // 5
  { x: 2, y:15, z:-2 }, // 6
  { x: 2, y:15, z: 2 }  // 7
];

/* 6 faces (quads), RANDOM COLOR PER FACE */
const faces = [
  {
    indices: [0, 1, 3, 2],
    color: `hsl(${Math.random()*360},70%,60%)`,
    alpha: 0.35
  },
  {
    indices: [4, 5, 7, 6],
    color: `hsl(${Math.random()*360},70%,60%)`,
    alpha: 0.35
  },
  {
    indices: [0, 1, 5, 4],
    color: `hsl(${Math.random()*360},70%,60%)`,
    alpha: 0.35
  },
  {
    indices: [2, 3, 7, 6],
    color: `hsl(${Math.random()*360},70%,60%)`,
    alpha: 0.35
  },
  {
    indices: [0, 2, 6, 4],
    color: `hsl(${Math.random()*360},70%,60%)`,
    alpha: 0.35
  },
  {
    indices: [1, 3, 7, 5],
    color: `hsl(${Math.random()*360},70%,60%)`,
    alpha: 0.35
  }
];

/* ================= CAMERA ================= */

let camPos  = { x:0, y:16, z:10 };
let camrotx = 0; // pitch
let camroty = 0; // yaw
let fov     = 38;

/* ================= INPUT ================= */

/* Existing mobile joystick and look handlers kept unchanged */
const joystick = {
  active:false,
  baseX:0,
  baseY:0,
  dx:0,
  dy:0,
  radius:60
};

let joystickTouchId = null;
let lookTouchId = null;
let lastLookX = 0;
let lastLookY = 0;

function getTouchById(e, id) {
  for (const t of e.touches) {
    if (t.identifier === id) {
      return { x:t.clientX, y:t.clientY };
    }
  }
  return null;
}

if (IS_MOBILE) {

  canvas.addEventListener('touchstart', e => {
    for (const t of e.changedTouches) {
      if (t.clientX < canvas.clientWidth * 0.5 && joystickTouchId === null) {
        joystickTouchId = t.identifier;
        joystick.active = true;
        joystick.baseX = t.clientX;
        joystick.baseY = t.clientY;
        joystick.dx = joystick.dy = 0;
      }
      else if (t.clientX >= canvas.clientWidth * 0.5 && lookTouchId === null) {
        lookTouchId = t.identifier;
        lastLookX = t.clientX;
        lastLookY = t.clientY;
      }
    }
  }, { passive:false });

  canvas.addEventListener('touchmove', e => {

    /* joystick */
    if (joystickTouchId !== null) {
      const p = getTouchById(e, joystickTouchId);
      if (p) {
        let dx = p.x - joystick.baseX;
        let dy = p.y - joystick.baseY;
        const len = Math.hypot(dx, dy);
        if (len > joystick.radius) {
          dx = dx / len * joystick.radius;
          dy = dy / len * joystick.radius;
        }
        joystick.dx = dx / joystick.radius;
        joystick.dy = dy / joystick.radius;
      }
    }

    /* look */
    if (lookTouchId !== null) {
      const p = getTouchById(e, lookTouchId);
      if (p) {
        const dx = p.x - lastLookX;
        const dy = p.y - lastLookY;
        const sensitivity = 0.4;
        camroty -= dx * sensitivity;
        camrotx += dy * sensitivity;
        camrotx = Math.max(-89, Math.min(89, camrotx));
        lastLookX = p.x;
        lastLookY = p.y;
      }
    }

  }, { passive:false });

  canvas.addEventListener('touchend', e => {
    for (const t of e.changedTouches) {
      if (t.identifier === joystickTouchId) {
        joystickTouchId = null;
        joystick.active = false;
        joystick.dx = joystick.dy = 0;
      }
      if (t.identifier === lookTouchId) {
        lookTouchId = null;
      }
    }
  });
}

/* ================= GAMEPAD SUPPORT ================= */

let gpState = {
  leftX: 0,
  leftY: 0,
  rightX: 0,
  rightY: 0
};

function updateGamepad() {
  const gps = navigator.getGamepads ? navigator.getGamepads() : [];

  if (!gps) return;

  for (const gp of gps) {
    if (!gp) continue;

    // Standard gamepad mapping assumed (like Xbox/PS controllers)
    // Axes:
    // 0 = Left stick X (-1 left, +1 right)
    // 1 = Left stick Y (-1 up, +1 down)
    // 2 = Right stick X (-1 left, +1 right)
    // 3 = Right stick Y (-1 up, +1 down)

    gpState.leftX = gp.axes[0] || 0;
    gpState.leftY = gp.axes[1] || 0;
    gpState.rightX = gp.axes[2] || 0;
    gpState.rightY = gp.axes[3] || 0;
  }
}

/* ================= MATH ================= */

const deg = d => d * Math.PI / 180;

function rotateYawPitch(v, pitch, yaw) {
  const cy = Math.cos(yaw), sy = Math.sin(yaw);
  let x = v.x * cy - v.z * sy;
  let z = v.x * sy + v.z * cy;

  const cx = Math.cos(pitch), sx = Math.sin(pitch);
  let y = v.y * cx - z * sx;
  z = v.y * sx + z * cx;

  return { x, y, z };
}

function worldToCamera(p) {
  return rotateYawPitch({
    x:p.x - camPos.x,
    y:p.y - camPos.y,
    z:p.z - camPos.z
  }, deg(camrotx), deg(camroty));
}

/* ================= RENDER ================= */

function render() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const vw = canvas.clientWidth;
  const vh = canvas.clientHeight;
  const cx = vw * 0.5;
  const cy = vh * 0.5;

  const aspect = vw / vh;
  const scaleY = cy / Math.tan(deg(fov) * 0.5);

  /* === Update gamepad state === */
  updateGamepad();

  /* === Movement === */
  // Movement speed
  const speed = 0.08;

  // Mobile joystick movement
  if (IS_MOBILE && joystick.active) {
    const yaw = deg(camroty);
    camPos.x += ( Math.sin(yaw) * joystick.dy + Math.cos(yaw) * joystick.dx ) * speed;
    camPos.z += ( Math.cos(yaw) * joystick.dy - Math.sin(yaw) * joystick.dx ) * speed;
  }

  // Gamepad left stick movement (leftY reversed to match forward)
  if (!IS_MOBILE) {
    const yaw = deg(camroty);
    const moveX = gpState.leftX;
    const moveY = -gpState.leftY; // invert Y so up is forward

    // Deadzone threshold to prevent drift
    const deadzone = 0.15;

    let mx = Math.abs(moveX) > deadzone ? moveX : 0;
    let my = Math.abs(moveY) > deadzone ? moveY : 0;

    camPos.x += (Math.sin(yaw) * my + Math.cos(yaw) * mx) * speed;
    camPos.z += (Math.cos(yaw) * my - Math.sin(yaw) * mx) * speed;
  }

  /* === Rotation === */
  // Mobile look handled in touchmove events

  // Gamepad right stick rotation
  if (!IS_MOBILE) {
    // Sensitivity for rotation
    const sensitivity = 2.5;

    // Deadzone threshold to prevent drift
    const deadzone = 0.15;

    let rx = Math.abs(gpState.rightX) > deadzone ? gpState.rightX : 0;
    let ry = Math.abs(gpState.rightY) > deadzone ? gpState.rightY : 0;

    camroty -= rx * sensitivity;
    camrotx += ry * sensitivity;

    camrotx = Math.max(-89, Math.min(89, camrotx));
  }

  /* === Projection === */
  const proj = pointsWorld.map(p => {
    const cam = worldToCamera(p);
    if (cam.z >= 0) return { visible:false, camZ:cam.z };
    return {
      visible:true,
      camZ:cam.z,
      x: cx + (cam.x / -cam.z) * (scaleY / aspect),
      y: cy - (cam.y / -cam.z) * scaleY
    };
  });

  const draw = [];

  for (const f of faces) {
    let z=0, verts=[], ok=true;
    for (const i of f.indices) {
      const p = proj[i];
      if (!p.visible) { ok=false; break; }
      verts.push(p);
      z += p.camZ;
    }
    if (ok) draw.push({ ...f, verts, depth:z/f.indices.length });
  }

  draw.sort((a,b)=>a.depth-b.depth);

  for (const d of draw) {
    ctx.globalAlpha = d.alpha;
    ctx.beginPath();
    ctx.moveTo(d.verts[0].x,d.verts[0].y);
    for (let i=1;i<d.verts.length;i++) ctx.lineTo(d.verts[i].x,d.verts[i].y);
    ctx.closePath();
    ctx.fillStyle = d.color;
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  requestAnimationFrame(render);
}

render();

</script>
</body>
</html>
